# SPEC-005-B: Authentication and Session Management

| Field | Value |
|-------|-------|
| **Spec ID** | SPEC-005-B |
| **ADR Reference** | [ADR-005: RBAC Design](../ADR-005-RBAC-Design.md), [ADR-004: Backend Language and Framework](../ADR-004-Backend-Language-And-Framework.md) |
| **Date** | 2026-02-27 |
| **Status** | Active |

---

## Overview

This specification defines the authentication and session management implementation for Iris, using Argon2id for password hashing and JWT-based session management.

---

## Password Hashing

| Parameter | Value | Rationale |
|-----------|-------|-----------|
| **Algorithm** | Argon2id | OWASP and NIST recommended. Resistant to GPU and side-channel attacks. |
| **Library** | `argon2-cffi` | Reference implementation binding for Python |
| **time_cost** | 3 | OWASP recommended minimum |
| **memory_cost** | 65536 (64 MB) | OWASP recommended minimum |
| **parallelism** | 4 | Matches typical server CPU cores |
| **hash_len** | 32 bytes | Standard output length |
| **salt_len** | 16 bytes | Auto-generated by argon2-cffi |

### Password Requirements

| Requirement | Value | Rationale |
|-------------|-------|-----------|
| Minimum length | 12 characters | NZISM 16.1.40.C.02 compliance |
| Maximum length | 128 characters | Prevent DoS via extremely long passwords |
| Complexity | At least 3 of: lowercase, uppercase, digits, special characters | NZISM option for 10+ char with complexity |
| Common password check | Yes — check against top 10,000 common passwords | NIST SP 800-63B alignment |
| Password history | Last 5 passwords | Prevent immediate reuse |

---

## Session Management

### Token Architecture

```
┌─────────────┐        ┌──────────────┐        ┌─────────────┐
│   Client     │──JWT──▶│  FastAPI      │──SQL──▶│  SQLite DB   │
│  (SvelteKit) │◀─JWT──│  Backend      │◀─SQL──│  (users,     │
│              │        │              │        │   refresh)   │
└─────────────┘        └──────────────┘        └─────────────┘
```

### Access Tokens (JWT)

| Parameter | Value |
|-----------|-------|
| **Format** | JWT (JSON Web Token) |
| **Algorithm** | HS256 |
| **Secret** | 256-bit minimum, stored in environment variable |
| **Expiry** | 15 minutes |
| **Claims** | `sub` (user ID), `role`, `exp`, `iat`, `jti` (unique token ID) |
| **Storage (client)** | In-memory only (not localStorage, not cookies) |
| **Transmission** | `Authorization: Bearer <token>` header |

### Refresh Tokens

| Parameter | Value |
|-----------|-------|
| **Format** | Opaque token (UUID v4) |
| **Storage (server)** | `refresh_tokens` table in SQLite |
| **Expiry** | 7 days |
| **Rotation** | New refresh token issued on each use; old token invalidated |
| **Revocation** | Delete from `refresh_tokens` table |
| **Family tracking** | Each refresh token family has a root ID; if a used token is reused, invalidate entire family (token theft detection) |

### Refresh Token Schema

```sql
CREATE TABLE refresh_tokens (
    id TEXT PRIMARY KEY,            -- The refresh token value (UUID)
    user_id TEXT NOT NULL REFERENCES users(id),
    family_id TEXT NOT NULL,        -- Root token ID for family tracking
    expires_at TEXT NOT NULL,       -- ISO 8601
    created_at TEXT NOT NULL DEFAULT (datetime('now')),
    used_at TEXT,                   -- Set when token is consumed
    revoked INTEGER NOT NULL DEFAULT 0
);

CREATE INDEX idx_refresh_tokens_user ON refresh_tokens(user_id);
CREATE INDEX idx_refresh_tokens_family ON refresh_tokens(family_id);
```

---

## User Schema

```sql
CREATE TABLE users (
    id TEXT PRIMARY KEY,            -- UUID
    username TEXT NOT NULL UNIQUE,
    password_hash TEXT NOT NULL,    -- Argon2id hash
    role TEXT NOT NULL DEFAULT 'viewer' REFERENCES roles(id),
    is_active INTEGER NOT NULL DEFAULT 1,
    failed_login_count INTEGER NOT NULL DEFAULT 0,
    locked_until TEXT,              -- ISO 8601, NULL if not locked
    last_login_at TEXT,             -- ISO 8601
    password_changed_at TEXT,       -- ISO 8601
    created_at TEXT NOT NULL DEFAULT (datetime('now')),
    updated_at TEXT NOT NULL DEFAULT (datetime('now'))
);

CREATE TABLE password_history (
    user_id TEXT NOT NULL REFERENCES users(id),
    password_hash TEXT NOT NULL,    -- Previous Argon2id hash
    changed_at TEXT NOT NULL DEFAULT (datetime('now')),
    PRIMARY KEY (user_id, changed_at)
);
```

---

## Authentication Flows

### Login

```
POST /api/auth/login
Body: { "username": "...", "password": "..." }

1. Look up user by username
2. If user not found → 401 (generic "Invalid credentials")
3. If user.locked_until > now → 401 ("Account locked")
4. Verify password against Argon2id hash
5. If invalid:
   a. Increment failed_login_count
   b. If failed_login_count >= 5 → set locked_until = now + 15 minutes
   c. Log auth.login_failed to audit
   d. Return 401 (generic "Invalid credentials")
6. If valid:
   a. Reset failed_login_count to 0
   b. Generate access token (JWT, 15 min)
   c. Generate refresh token (stored server-side)
   d. Log auth.login to audit
   e. Return { access_token, refresh_token, expires_in }
```

### Token Refresh

```
POST /api/auth/refresh
Body: { "refresh_token": "..." }

1. Look up refresh token in database
2. If not found or revoked → 401
3. If expired → 401
4. If already used (used_at is set):
   a. Token reuse detected → potential theft
   b. Revoke entire token family
   c. Log security incident to audit
   d. Return 401
5. Mark current refresh token as used
6. Generate new access token
7. Generate new refresh token (same family_id)
8. Return { access_token, refresh_token, expires_in }
```

### Logout

```
POST /api/auth/logout
Header: Authorization: Bearer <access_token>

1. Extract user from access token
2. Revoke all refresh tokens for user (or specific family)
3. Log auth.logout to audit
4. Return 200
```

### Password Change

```
POST /api/auth/change-password
Header: Authorization: Bearer <access_token>
Body: { "current_password": "...", "new_password": "..." }

1. Verify current password
2. Validate new password (length, complexity, not in history)
3. Hash new password with Argon2id
4. Store old hash in password_history
5. Update users.password_hash and users.password_changed_at
6. Revoke all refresh tokens for user
7. Log auth.password_change to audit
8. Return 200
```

---

## Rate Limiting

| Endpoint | Limit | Window |
|----------|-------|--------|
| `POST /api/auth/login` | 10 requests | 1 minute (per IP) |
| `POST /api/auth/refresh` | 30 requests | 1 minute (per IP) |
| All other endpoints | 100 requests | 1 minute (per user) |

Rate limiting is implemented as FastAPI middleware, using in-memory counters with sliding window. Returns HTTP 429 when exceeded.

---

## Security Headers

Set by middleware on all responses:

```python
Strict-Transport-Security: max-age=31536000; includeSubDomains
X-Content-Type-Options: nosniff
X-Frame-Options: DENY
Referrer-Policy: strict-origin-when-cross-origin
```

---

## First-Run Setup

On first application startup when no users exist:

1. Prompt for admin username and password (CLI or setup endpoint)
2. Create user with `admin` role
3. Log `user.create` to audit
4. Disable the setup endpoint after first user creation

---

*This specification implements [ADR-005](../ADR-005-RBAC-Design.md) and [ADR-004](../ADR-004-Backend-Language-And-Framework.md).*
